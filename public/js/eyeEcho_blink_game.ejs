// eyeEcho elements
const eyeEchoResultImageEl = document.getElementById('eyeEcho_result_image_element');
const eyeEchoResultBlinkCountEl = document.getElementById('eyeEcho_result_info_blink_count');
const eyeEchoResultBlinkPeriodEl = document.getElementById('eyeEcho_result_info_blink_period');

function setResultImageSrc(imgUrl) {
    eyeEchoResultImageEl.src = imgUrl;
}

function setResultBlinkCount() {
    eyeEchoResultBlinkCountEl.innerHTML = eyeEcho_result_info.count;
    eyeEchoResultBlinkPeriodEl.innerHTML = eyeEcho_result_info.period;
}

function loadJSON(path, success, error) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
            if (xhr.status === 200) {
                if (success)
                    success(JSON.parse(xhr.responseText));
            } else {
                if (error)
                    error(xhr);
            }
        }
    };
    xhr.open("GET", path, true);
    xhr.send();
}

function eyeEcho_load_menu_data(callback) {
    loadJSON(
        './lang/' + eyeEcho_game_config.lang + '.json',
        (data) => {
            eyeEcho_game_config.text = data;
            eyeEcho_game_config.isLoading = false;
            callback();
        },
        (error) => {
            console.log("menu loading error: ", error);
        }
    );
}

const o = Math.round;
const f = Math.floor;
const r = Math.random;

const BIG_INT = 100000000;
const SHAPE_SIZE_MIN = 100;
const CHOR_MIN = 100;
const ALPHA_MIN = 0.6;

const GRADIENT_TYPE = {
    SOLID: 'SOLID',
    LINEAR: 'LINEAR',
    RADIAL: 'RADIAL',
}

const SHAPE_TYPE = {
    CIRCLE: {
        name: 'CIRCLE',
        r: SHAPE_SIZE_MIN / 2
    },
    SQUARE: {
        name: 'SQUARE',
        x: SHAPE_SIZE_MIN,
        y: SHAPE_SIZE_MIN
    },
    THIN_RECTANGLE: {
        name: 'THIN_RECTANGLE',
        x: SHAPE_SIZE_MIN * 2,
        y: SHAPE_SIZE_MIN / 5
    },
    LARGE_RECTANGLE: {
        name: 'LARGE_RECTANGLE',
        x: SHAPE_SIZE_MIN * 2,
        y: SHAPE_SIZE_MIN / 3
    },
    TRIANGLE: {
        name: 'TRIANGLE',
        r: SHAPE_SIZE_MIN / Math.SQRT2
    },
}

const BREAK_POINT = {
    DESKTOP: 1280, // 1280 * 800
    iPAD_PRO: 1024, //1024 * 1366
    iPAD: 768, // 768 * 1024
    iPhone6: 414, // 414 * 736
    iPhoneX: 375, // 375 * 812
    iPhone5: 320, // 320 * 568
}

/**
 * functions to set game config
 */
//set language
function setLanguage(lang) {
    eyeEcho_game_config.lang = lang
}

/**
 * utils to draw shape on canvas
 */
// check a is between b and c
function isWithin(a, b, c) {
    return a >= b && a <= c
};

// get randomized integer
function getRandomInt(range = BIG_INT) {
    return o(r() * range);
}

// get statistic option
function getStc(a = 2, b = 1) {
    return getRandomInt() % a < b ? true : false;
}

// interval just few times
function setIntervalX(callback, delay = 1000, repetitions = 0) {
    let x = 0;
    let intervalId = setInterval(() => {
        callback();
        if (++x === repetitions) {
            clearInterval(intervalId);
        }
    }, delay);
}

// convert hex to rgb
function hexToR(h) {
    return parseInt((cutHex(h)).substring(0, 2), 16)
}

function hexToG(h) {
    return parseInt((cutHex(h)).substring(2, 4), 16)
}

function hexToB(h) {
    return parseInt((cutHex(h)).substring(4, 6), 16)
}

function cutHex(h) {
    return (h.charAt(0) == "#") ? h.substring(1, 7) : h
}

function hexToRgb(_hex) {
    return [hexToR(_hex), hexToG(_hex), hexToB(_hex), 1.0];
}

function ColorLuminance(hex, lum) {
    // validate hex string
    hex = String(hex).replace(/[^0-9a-f]/gi, '');
    if (hex.length < 6) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    lum = lum || 0;

    // convert to decimal and change luminosity
    var rgb = "#",
        c, i;
    for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i * 2, 2), 16);
        c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
        rgb += ("00" + c).substr(c.length);
    }

    return rgb;
}

function getThemeColors(theme = 'grey') {
    theme = eyeEcho_game_config.theme;
    return eyeEcho_game_config.text.theme[theme];
}

// get rgba style
function getRgbaColor(rgba) {
    return `rgba(${o(rgba[0]) % 256}, ${o(rgba[1]) % 256}, ${o(rgba[2]) % 256}, ${rgba[3] < 1 ? rgba[3] < ALPHA_MIN ? 1 : rgba[3] : 1})`;
}


// unify vector
function unifyVector(_vec) {
    const _l = Math.sqrt(_vec.x * _vec.x + _vec.y * _vec.y);
    return {
        x: _vec.x / _l,
        y: _vec.y / _l
    };
}

animate = ({
    duration,
    draw,
    timing
}) => {
    let start = performance.now();
    requestAnimationFrame(animateFrame = (time) => {
        let timeFraction = (time - start) / duration;
        dropingProgress = timeFraction;
        if (timeFraction > 1) {
            timeFraction = 1;
        }
        let progress = timing(timeFraction)
        draw(progress);
        if (timeFraction && timeFraction < 1) {
            window.requestAnimationFrame(animateFrame);
        }
    });
}


// defind Shape class
let Shape = function(ctx, width, height, zIndex=0) {
    let self = {};

        self.box = {
            width: width,
            height: height,
            area: width * height
        };
    
        // z-index
        self.z = zIndex;
    
        /** set the canvas context 2d */
        self.ctx = ctx;
    
        /** set the shape's type and width, height, radius */
        self.setType = () => {
            self.scale = r() * (self.box.width / SHAPE_SIZE_MIN - 2) + 1;
            const _t = getRandomInt() % 14;
            if (_t < 2) {
                self.type = SHAPE_TYPE.THIN_RECTANGLE;
                self.width = self.type.x * self.scale;
                self.height = self.type.y * self.scale;
                self.r = Math.sqrt(self.width * self.width + self.height * self.height) / 2;
            } else if (_t < 6) {
                self.type = SHAPE_TYPE.LARGE_RECTANGLE;
                self.width = self.type.x * self.scale;
                self.height = self.type.y * self.scale;
                self.r = Math.sqrt(self.width * self.width + self.height * self.height) / 2;
            } else if (_t < 9) {
                self.type = SHAPE_TYPE.CIRCLE;
                self.r = self.type.r * self.scale;
                self.width = self.r * 2;
                self.height = self.r * 2;
            } else if (_t < 11) {
                self.type = SHAPE_TYPE.TRIANGLE;
                self.r = self.type.r * self.scale;
                self.width = self.r * 2;
                self.height = self.r * 2;
            } else {
                self.type = SHAPE_TYPE.SQUARE;
                self.width = self.type.x * self.scale;
                self.height = self.type.y * self.scale;
                self.r = Math.sqrt(self.width * self.width + self.height * self.height) / 2;
            }
        }
    
        /** set shape's velocity with speed and direction */
        self.setVelocity = () => {
            let _start_p = {
                    x: 0,
                    y: 0
                },
                _end_p = {
                    x: 0,
                    y: 0
                };
            const _o = [self.width / 2, self.height / 2];
            const box = {
                width: self.box.width,
                height: self.box.height,
            };
    
            let direction = getRandomInt() % 4;
    
            switch (direction) {
                case 0: // right
                    _start_p.x = -_o[0] / 2;
                    _start_p.y = r() * box.height;
                    _end_p.x = box.width + _o[0] / 2;
                    _end_p.y = r() * box.height;
                    if (self.width < self.height) {
                        const _t = self.height;
                        self.height = self.width;
                        self.width = _t;
                        _start_p.x = self.width / 2;
                    }
                    break;
                case 1: // down
                    _start_p.x = r() * box.width;
                    _start_p.y = -_o[1] / 2;
                    _end_p.x = r() * box.width;
                    _end_p.y = box.height + _o[1];
                    if (self.width > self.height) {
                        const _t = self.height;
                        self.height = self.width;
                        self.width = _t;
                        _start_p.y = -self.height / 2;
                    }
                    break;
                case 2: // left
                    _start_p.x = box.width + _o[0] / 2;
                    _start_p.y = r() * box.height;
                    _end_p.x = -_o[0];
                    _end_p.y = r() * box.height;
                    if (self.width < self.height) {
                        const _t = self.height;
                        self.height = self.width;
                        self.width = _t;
                        _start_p.x = box.width + self.width / 2;
                    }
                    break;
                case 3: // up
                    _start_p.x = r() * box.width;
                    _start_p.y = box.height + _o[1] / 2;
                    _end_p.x = r() * box.width;
                    _end_p.y = -_o[1];
                    if (self.width > self.height) {
                        const _t = self.height;
                        self.height = self.width;
                        self.width = _t;
                        _start_p.y = box.height + self.height / 2;
                    }
                    break;
                default:
                    _end_p.x = -_o[0];
                    _end_p.y = r() * box.height;
                    _start_p.x = box.width + _o[0] / 2;
                    _start_p.y = r() * box.height;
                    break;
            }
    
            self.start_p = _start_p;
            self.end_p = _end_p;
    
            self.x = self.start_p.x;
            self.y = self.start_p.y;
    
            let _a = {
                x: _end_p.x - _start_p.x,
                y: _end_p.y - _start_p.y
            };
    
            if (self.width > self.height) {
                if (getRandomInt() % 3 == 0) {
                    _a.y = _a.y < 0 ? -Math.abs(_a.x) : Math.abs(_a.x);
                } else {
                    _a.y = 0;
                }
            }
    
            if (self.width < self.height) {
                if (getRandomInt() % 4 == 0) {
                    _a.x = _a.x < 0 ? -Math.abs(_a.y) : Math.abs(_a.y);
                } else {
                    _a.x = 0;
                }
            }
    
            if (_a.x == 0) {
                self.start_angle = Math.PI / 2;
            } else {
                self.start_angle = Math.atan2(_a.y, _a.x);
            }
    
            self.direction = _a;
            self.speed = r() * box.width / 200 + box.width / 300;
        }
    
        self.setGradient = () => {
            const _t = getRandomInt() % 7;
    
            if (_t < 1) {
                self.grd_type = GRADIENT_TYPE.SOLID;
            } else if (_t < 4) {
                self.grd_type = GRADIENT_TYPE.LINEAR;
            } else {
                self.grd_type = GRADIENT_TYPE.RADIAL;
            }
    
            self.grd_center = getRandomInt() % 5;
    
        }
    
        self.setColor = () => {
            const themeColors = getThemeColors();
            self.color = [
                themeColors.value1,
                themeColors.value2,
                themeColors.value3,
            ];
    
            let colorPrx = self.z % 2 == 0 ? f(self.z / 2 + 2) : -f(self.z / 2);
            let color_step = 0.01;
            const theme = eyeEcho_game_config.theme;
            let color_offset = 0;
            if (colorPrx > 0) {
                if (theme == 'red') {
                    color_step = 0.01;
                    color_offset = 0.3;
                }
    
                if (theme == 'light-blue') {
                    color_step = 0.02;
                    color_offset = 0.2;
                }
            }
    
            const colors = [
                ColorLuminance(themeColors.value2, colorPrx * color_step + r() * color_step - color_offset),
                ColorLuminance(themeColors.value1, colorPrx * color_step + r() * 0.8 - 0.1),
                ColorLuminance(themeColors.value3, colorPrx * color_step + r() * 0.8 - 0.1),
                ColorLuminance(themeColors.value2, colorPrx * color_step - color_offset),
                ColorLuminance(themeColors.value2, colorPrx * color_step - color_offset),
                ColorLuminance(themeColors.value2, colorPrx * color_step - color_offset),
                ColorLuminance(themeColors.value2, colorPrx * color_step - color_offset),
            ];
    
            const _t = getRandomInt();
            const area = self.width * self.height;
            if (area > self.box.area / 8) {
                self.color[0] = ColorLuminance(themeColors.value2, colorPrx * color_step - color_offset);
                self.color[1] = ColorLuminance(themeColors.value2, colorPrx * color_step + r() * color_step - color_offset);
            } else {
                self.color[0] = colors[getRandomInt() % 7];
                self.color[1] = colors[getRandomInt() % 5];
                self.color[2] = colors[getRandomInt() % 4];
            }
    
            if (self.grd_type !== GRADIENT_TYPE.SOLID && area < self.box.area / 6) {
                self.color[1] = colors[getRandomInt() % 4];
                self.color[2] = colors[getRandomInt() % 4];
            }
        }
    
        self.move = () => {
            if (self.direction.x == 0) {
                self.y += self.direction.y > 0 ? self.speed : -self.speed;
            } else if (self.direction.y == 0) {
                self.x += self.direction.x > 0 ? self.speed : -self.speed;
            } else {
                const direction = unifyVector(self.direction);
                self.x += self.speed * direction.x;
                self.y += self.speed * direction.y;
            }
        }
    
        // define draw functions
        self.drawRect = () => {
            const grd_len = self.r ? self.r * 2 : self.width * 2;
            self.ctx.save();
            let x = self.x;
            let y = self.y;
    
            if (self.width !== self.height && self.start_angle != Math.PI / 2) {
                self.ctx.translate(self.x, self.y);
                self.ctx.rotate(self.start_angle);
                x = 0;
                y = 0;
            }
    
            self.ctx.beginPath();
            self.ctx.rect(x - self.width / 2, y - self.height / 2, self.width, self.height);
            let grd;
            switch(self.grd_type) {
                case GRADIENT_TYPE.SOLID:
                    grd = self.ctx.createLinearGradient(x - self.width / 2, y - self.height / 2, x + self.width / 2, y + self.height / 2);
                    grd.addColorStop(0, self.color[0]);
                    break;
                case GRADIENT_TYPE.LINEAR:
                    grd = self.ctx.createLinearGradient(x - self.width / 2, y - self.height / 2, x + self.width / 2, y + self.height / 2);
                    grd.addColorStop(0, self.color[0]);
                    grd.addColorStop(1, self.color[1]);
                    break;
                case GRADIENT_TYPE.RADIAL:
                    switch(self.grd_center) {
                        case 0:
                            x = x + self.width / 2;
                            y = y + self.height / 2;
                            break;
                        case 1:
                            x = x - self.width / 2;
                            y = y + self.height / 2;
                            break;
                        case 2:
                            x = x + self.width / 2;
                            y = y - self.height / 2;
                            break;
                        case 3:
                            x = x - self.width / 2;
                            y = y - self.height / 2;
                            break;
                    }
    
                    grd = self.ctx.createRadialGradient(x, y, 0, x, y, grd_len);
    
                    grd.addColorStop(1, self.color[0]);
                    grd.addColorStop(0, self.color[1]);
                    break;
            }
    
            self.ctx.fillStyle = grd;
            self.ctx.fill();
            self.ctx.closePath();
            self.ctx.restore();
        }
    
        self.drawCircle = () => {
            self.ctx.beginPath();
            self.ctx.arc(self.x, self.y, self.r, 0, Math.PI * 2);
            let grd;
            switch(self.grd_type) {
                case GRADIENT_TYPE.SOLID:
                    grd = self.ctx.createLinearGradient(self.x - self.r, self.y - self.r, self.x + self.r, self.y + self.r);
                    grd.addColorStop(0, self.color[0]);
                    grd.addColorStop(1, self.color[1]);
                    break;
                case GRADIENT_TYPE.LINEAR:
                    grd = self.ctx.createLinearGradient(self.x - self.r, self.y - self.r, self.x + self.r, self.y + self.r);
                    grd.addColorStop(0, self.color[0]);
                    grd.addColorStop(1, self.color[1]);
                    break;
                case GRADIENT_TYPE.RADIAL:
                    grd = self.ctx.createRadialGradient(self.x, self.y, 0, self.x, self.y, self.r * 2);
                    grd.addColorStop(0, self.color[0]);
                    grd.addColorStop(1, self.color[1]);
                    break;
            }
    
            self.ctx.fillStyle = grd;
            self.ctx.fill();
            self.ctx.closePath();
        }
    
        self.drawTriangle = () => {
            const ang_step = 120 / 180 * Math.PI;
            const p1 = [self.x + self.r * Math.cos(self.start_angle), self.y + self.r * Math.sin(self.start_angle)];
            const p2 = [self.x + self.r * Math.cos(self.start_angle + ang_step), self.y + self.r * Math.sin(self.start_angle + ang_step)];
            const p3 = [self.x + self.r * Math.cos(self.start_angle + 2 * ang_step), self.y + self.r * Math.sin(self.start_angle + 2 * ang_step)];
    
            self.ctx.beginPath();
            self.ctx.moveTo(p1[0], p1[1]);
            self.ctx.lineTo(p2[0], p2[1]);
            self.ctx.lineTo(p3[0], p3[1]);
    
            let grd;
            switch(self.grd_type) {
                case GRADIENT_TYPE.SOLID:
                    grd = self.ctx.createLinearGradient(self.x - self.r, self.y - self.r, self.x + self.r, self.y + self.r);
                    grd.addColorStop(0, self.color[0]);
                    break;
                case GRADIENT_TYPE.LINEAR:
                    grd = self.ctx.createLinearGradient(self.x - self.r, self.y - self.r, self.x + self.r, self.y + self.r * 2);
                    grd.addColorStop(0, self.color[0]);
                    grd.addColorStop(1, self.color[1]);
                    break;
                case GRADIENT_TYPE.RADIAL:
                    switch(self.grd_center) {
                        case 0:
                            grd = self.ctx.createRadialGradient(self.x, self.y, 0, self.x, self.y, self.r * 2);
                            break;
                        case 1:
                            grd = self.ctx.createRadialGradient(p1[0], p1[1], 0, p1[0], p1[1], self.r * 2);
                            break;
                        case 1:
                            grd = self.ctx.createRadialGradient(p2[0], p2[1], 0, p2[0], p2[1], self.r * 2);
                            break;
                        default:
                            grd = self.ctx.createRadialGradient(p3[0], p3[1], 0, p3[0], p3[1], self.r * 2);
                            break;
    
                    }
                    grd.addColorStop(0, self.color[0]);
                    grd.addColorStop(1, self.color[1]);
                    break;
            }
    
            self.ctx.fillStyle = grd;
            self.ctx.fill();
            self.ctx.closePath();
        }
    
        self.draw = () => {
            switch (self.type) {
                case SHAPE_TYPE.SQUARE:
                    self.drawRect();
                    break;
                case SHAPE_TYPE.THIN_RECTANGLE:
                    self.drawRect();
                    break;
                case SHAPE_TYPE.LARGE_RECTANGLE:
                    self.drawRect();
                    break;
                case SHAPE_TYPE.CIRCLE:
                    self.drawCircle();
                    break;
                case SHAPE_TYPE.TRIANGLE:
                    self.drawTriangle();
                    break;
            }
        }
    
        self.init = () => {
            /** set the shape type randomly */
            self.setType();
    
            /** set shape's velocity */
            self.setVelocity();
    
            /** set gradient property */
            self.setGradient();
    
            /** set color */
            self.setColor();
        }

        self.getX = () => self.x;
        self.getY = () => self.y;
        self.getWidth = () => self.width;
        self.getHeight = () => self.height;
        self.getR = () => self.r;

    self.init();

    return self;
};


const GameBoard = function(canvas) {

    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.theme = eyeEcho_game_config.theme;
    this.bg_color = eyeEcho_game_config.text.theme[this.theme];

    const setActiveShape = () => {
        let newShape = Shape(this.ctx, this.width, this.height, this.staticShapes.length);
        this.activeShape = newShape;
    }

    const init = (countdown = eyeEcho_game_config.countdown) => {
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.lr_p = 0;
        this.t_p = this.height / 5;
        this.countdown = countdown;
        this.activeShape = null;
        this.staticShapes = [];
        this.touchedHeight = this.height;
        this.isStarted = false;
        this.isUploading = false;
        this.isReady = 4;
        this.countdownTimer = null;
        this.backgroundTimer = null;
        this.moveTimer = null;
        this.isEnableEye = false;
        this.blinkIcon = new Image();
        this.blinkIcon.setAttribute("crossOrigin", "Anonymous");
        this.blinkIcon.src = eyeEcho_game_config.eye_url;
        setActiveShape();

        //init global info values
        eyeEcho_result_info.count = 0;
        eyeEcho_result_info.period = 0;
    }

    const setCanvas = (canvas) => {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.theme = eyeEcho_game_config.theme;
        this.bg_color = eyeEcho_game_config.text.theme[this.theme];
        init();
    }

    const uploadImage = () => {
        try {
            this.isUploading = true;
            this.isEnableEye = false;
            const pngUrl = this.canvas.toDataURL("image/png", 1);
            setResultImageSrc(pngUrl);
            setResultBlinkCount();
            drawMenu();

            const url = 'https://imb-staging.herokuapp.com/eye-echo/upload';
            fetch(url, {
                    method: 'POST',
                    headers: {
                        Accept: 'application/json',
                        'Content-Type': 'application/json;charset=UTF-8'
                    },
                    body: JSON.stringify({
                        "image": pngUrl
                    })
                })
                .then(resp => resp.json())
                .then(data => {
                    this.isUploading = false;
                    if (data.status === 'error') {
                        alert('error: ', data.message);
                    } else {
                        //alert(data.message + '\n' + eyeEcho_menu[eyeEcho_game_config.lang].uploading.success + '\n' + data.image_url);
                        eyeEchoPage('eyeEcho_results_page', 'eyeEcho_result_created_image');
                    }
                    eyeEchoSendGA('uploaded-image');
                    drawMenu();
                });
        } catch (err) {
            console.log(err);
            this.isUploading = false;
            drawMenu();
        }
    }

    const endGame = () => {
        if (!this.isStarted) return;
        clearInterval(this.countdownTimer);
        clearInterval(this.moveTimer);
        this.isStarted = false;
        uploadImage();
    }

    const addStaticShape = () => {
        const oldShape = this.activeShape;
        console.log(this.activeShape)
        this.staticShapes.push(oldShape);
    }

    // check the active shape is out of board and set top height
    const checkShape = () => {
        const x = this.activeShape.getX();
        const y = this.activeShape.getY();
        const width = this.activeShape.getWidth();
        const height = this.activeShape.getHeight();
        const r = Math.sqrt(width * width + height * height) / 2;

        if ((x + r) < 0 || (x - r) > this.width || (y + r) < 0 || (y - r) > this.height) {
            console.log("outed shape..")
            setActiveShape();
        }
    }

    // check if end condition
    const checkEndCondition = () => {
        return this.countdown < 1;
    }

    // drop shape
    const dropShape = () => {
        eyeEcho_result_info.count++;
        if (!this.isStarted) return;
        this.isEnableEye = true;

        setTimeout(() => {
            this.isEnableEye = false;
        }, 300);

        addStaticShape();
        setActiveShape();
    }

    // move shape left or right
    const moveShape = () => {
        checkShape();
        this.activeShape.move();
    }

    // define draw functions
    const erase = () => {
        this.ctx.restore();
        this.ctx.save();
        this.ctx.clearRect(0, 0, this.width, this.height);
    }

    // draw ready to start
    const drawReadyToStart = () => {
        if (this.isReady < 1) {
            animate({
                duration: 1000,
                draw: (progress) => {
                    if (progress >= 1) {
                        startGame();
                        return;
                    }
                    if (progress < 0) return;
                    const _r = 1000 * progress + this.width / 5;
                    erase();
                    this.ctx.beginPath();
                    this.ctx.arc(this.width / 2, this.height / 2, Math.abs(_r), 0, Math.PI * 2);
                    this.ctx.clip();
                    drawBackground(_r, _r);
                    this.ctx.fillStyle = "rgba(255, 255, 255, " + (0.6 - progress > 0 ? 0.6 - progress : 0.0) + ")";
                    this.ctx.font = 'bold ' + (20 + 20 * progress) + 'vw Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    const txtHeight = this.ctx.measureText('3').width;
                    this.ctx.fillText(1, this.width / 2, this.height / 2 + txtHeight / 6);
                },
                timing: (timeFraction) => {
                    return timeFraction;
                }
            });
        } else if (this.isReady > 3) {
            animate({
                duration: 1000,
                draw: (progress) => {
                    if (progress < 0) return;
                    erase();
                    this.ctx.beginPath();
                    this.ctx.arc(this.width / 2, this.height / 2, this.width / 5, 0, Math.PI * 2);
                    this.ctx.closePath();
                    this.ctx.clip();
                    this.ctx.globalAlpha = progress;
                    drawBackground(this.width / 5, this.width / 5);
                    this.ctx.fillStyle = "rgba(255, 255, 255, " + progress + ")";
                    this.ctx.font = 'bold 20vw Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    const txtHeight = this.ctx.measureText('3').width;
                    this.ctx.fillText(3, this.width / 2, this.height / 2 + txtHeight / 6);
                },
                timing: (timeFraction) => {
                    return timeFraction;
                }
            });
        } else {
            erase();
            this.ctx.beginPath();
            this.ctx.arc(this.width / 2, this.height / 2, this.width / 5, 0, Math.PI * 2);
            this.ctx.clip();
            drawBackground(this.width / 5, this.width / 5);
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.font = 'bold 20vw Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            const txtHeight = this.ctx.measureText('3').width;
            this.ctx.fillText(this.isReady, this.width / 2, this.height / 2 + txtHeight / 6);
        }
    }

    // draw menu to show how to play game
    const drawMenu = () => {
        if (this.isUploading) {
            this.ctx.fillStyle = '#000000';
            this.ctx.font = '6vw Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(eyeEcho_game_config.text.game.uploading.title, this.width / 2, this.height / 2);
            this.ctx.font = '4vw Arial'
            this.ctx.fillText(eyeEcho_game_config.text.game.uploading.description, this.width / 2, (this.height / 4) * 3);
            return;
        }
    }

    // draw time remaining
    const drawCountdown = () => {
        if (this.countdown < 1) return;

        this.ctx.fillStyle = '#FFF';
        this.ctx.textAlign = 'left';
        this.ctx.textBaseline = 'middle';
        this.ctx.font = '8vw Arial Black';

        const txtHeight = this.ctx.measureText('M').width;
        const countdownTextWidth = this.ctx.measureText(this.countdown);

        this.ctx.fillText(this.countdown, txtHeight / 2, txtHeight);
        this.ctx.font = '4vw Arial';
        this.ctx.fillText(' sec', txtHeight / 2 + countdownTextWidth.width, txtHeight);

        this.ctx.textAlign = 'right';
        this.ctx.font = '4vw Arial';
        const blinksTextWidth = this.ctx.measureText(' blinks');
        this.ctx.fillText(' blinks', this.width - txtHeight / 2, txtHeight);
        this.ctx.font = '8vw Arial Black';
        this.ctx.fillText(eyeEcho_result_info.count, this.width - txtHeight / 2 - blinksTextWidth.width, txtHeight);

    }

    // draw shapes
    const drawShapes = () => {
        this.staticShapes.forEach(function (shape) {
            shape.draw();
        })
    }

    // draw blink icon when the shape start to drop
    const drawBlinkIcon = () => {
        if (this.isEnableEye && !this.isUploading) {
            this.ctx.drawImage(this.blinkIcon, this.width / 2 - this.width / 10, this.height / 2 - this.width / 10, this.width / 5, this.width / 5);
        }
    }

    // draw gradient background.
    const drawBackground = (offset_x = this.width / 2, offset_y = this.height / 2) => {

        if (offset_x == 0 || offset_x > this.width / 2) {
            offset_x = this.width / 2, offset_y = this.height / 2;
        }

        let grd = this.ctx.createLinearGradient(
            this.width / 2 - offset_x,
            this.height / 2 - offset_y,
            this.width / 2 + offset_x,
            this.height / 2 + offset_y);
        grd.addColorStop(0, this.bg_color.value1 + "99");
        grd.addColorStop(0.4, this.bg_color.value2);
        //grd.addColorStop(0.7, this.bg_color.value2);
        grd.addColorStop(1, this.bg_color.value3 + "99");
        this.ctx.fillStyle = grd;
        this.ctx.fillRect(this.width / 2 - offset_x, this.height / 2 - offset_y, this.width / 2 + offset_x, this.height / 2 + offset_y);
    }

    // draw by time
    const draw = (time) => {
        erase();
        drawBackground(this.width / 2, this.height / 2);
        drawShapes();
        if (checkEndCondition()) {
            endGame();
        } else {
            this.activeShape.draw();
            drawCountdown();
            drawBlinkIcon();
            window.requestAnimationFrame(draw);
        }
    }

    const readyToStart = () => {
        drawReadyToStart();
        setIntervalX(() => {
            this.isReady--;
            drawReadyToStart();
        }, 1000, 4);
    }

    const startGame = () => {
        if (this.isStarted || this.isUploading)
            return;

        init();

        this.isStarted = true;

        this.countdownTimer = setInterval(() => {
            this.countdown--;
            eyeEcho_result_info.period++;
        }, 1000);

        this.moveTimer = setInterval(() => {
            moveShape();
        }, 1);

        draw();
    }

    return {startGame, readyToStart, setCanvas, dropShape, endGame}
};

/**
 *  get elements
 */

const eyeEcho_blink_game_container = document.getElementById('eyeEcho_blink_game_container');
const eyeEcho_blink_game_canvas = document.getElementById("eyeEcho_blink_game_board");
const eyeEcho_blink_game_ctx = eyeEcho_blink_game_canvas.getContext("2d");

/**
 * set class name to change eyeEcho_blink_game_canvas game board width dynamically by eyeEcho_blink_game_container's boundbox size
 */

chageWidthClass = () => {
    if (!gameboard) return;
    eyeEcho_blink_game_canvas.width = eyeEcho_blink_game_container.offsetWidth;
    eyeEcho_blink_game_canvas.height = eyeEcho_blink_game_container.offsetHeight;

    gameboard.setCanvas(eyeEcho_blink_game_canvas);
}

eyeEcho_translate = () => {
    const allDom = document.getElementsByTagName("*");
    for (let i = 0; i < allDom.length; i++) {
        const elem = allDom[i];
        const key = elem.getAttribute("eyeEcho-data-tag");
        if (key != null) {
            elem.innerHTML = eyeEcho_game_config.text.page[key];
        }
    }
}

createGameBoard = () => {

    eyeEcho_translate();

    gameboard = new GameBoard(eyeEcho_blink_game_canvas);

    chageWidthClass();

    //window.addEventListener('resize', chageWidthClass);

    //eyeEcho_blink_game_canvas.addEventListener('click', gameboard.startGame);

    document.addEventListener('mousedown', function (event) {
        lastDownTarget = event.target;
    }, false);

    document.addEventListener('keydown', function (e) {
        if (lastDownTarget == eyeEcho_blink_game_canvas) {
            e.preventDefault();
            if (e.keyCode === 40) {
                gameboard.dropShape();
            }
        }
    }, false);
}

eyeEcho_load_menu_data(createGameBoard);
