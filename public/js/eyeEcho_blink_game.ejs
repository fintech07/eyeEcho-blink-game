// elements
const eyeEchoResultImageEl = document.getElementById('eyeEcho_result_image_element');
const eyeEchoResultBlinkCountEl = document.getElementById('eyeEcho_result_info_blink_count');
const eyeEchoResultBlinkPeriodEl = document.getElementById('eyeEcho_result_info_blink_period');

function setResultImageSrc(imgUrl) {
    eyeEchoResultImageEl.src = imgUrl;
}

function setResultBlinkCount() {
    eyeEchoResultBlinkCountEl.innerHTML = eyeEcho_result_info.count;
    eyeEchoResultBlinkPeriodEl.innerHTML = eyeEcho_result_info.period;
}

function loadJSON(path, success, error) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
            if (xhr.status === 200) {
                if (success)
                    success(JSON.parse(xhr.responseText));
            } else {
                if (error)
                    error(xhr);
            }
        }
    };
    xhr.open("GET", path, true);
    xhr.send();
}

function eyeEcho_load_menu_data(callback) {
    loadJSON(
        './lang/' + eyeEcho_game_config.lang + '.json',
        (data) => {
            eyeEcho_game_config.text = data;
            eyeEcho_game_config.isLoading = false;
            callback();
        },
        (error) => {
            console.log("menu loading error: ", error);
        }
    );
}

const o = Math.round;
const f = Math.floor;
const r = Math.random;

const BIG_INT = 100000000;
const SHAPE_SIZE_MIN = 50;
const CHOR_MIN = 100;
const ALPHA_MIN = 0.6;

const LANG = {
    EN: 'en',
    RU: 'ru',
}

const SHAPE_TYPE = {
    CIRCLE: 'CIRCLE',
    RECTANGLE: 'RECTANGLE',
    TRIANGLE: 'TRIANGLE',
}

const BREAK_POINT = {
    DESKTOP: 1280, // 1280 * 800
    iPAD_PRO: 1024, //1024 * 1366
    iPAD: 768, // 768 * 1024
    iPhone6: 414, // 414 * 736
    iPhoneX: 375, // 375 * 812
    iPhone5: 320, // 320 * 568
}

//set language
function setLanguage(lang) {
    eyeEcho_game_config.lang = lang
}

// check a is between b and c
function isWithin(a, b, c) {
    return a >= b && a <= c
};

// get randomized integer
function getRandomInt(range = BIG_INT) {
    return o(r() * range);
}

// get statistic option
function getStc(a = 2, b = 1) {
    return getRandomInt() % a < b ? true : false;
}

// interval few times
function setIntervalX(callback, delay = 1000, repetitions = 0) {
    let x = 0;
    let intervalId = setInterval(() => {
        callback();
        if (++x === repetitions) {
            clearInterval(intervalId);
        }
    }, delay);
}


// convert hex to rgb
function hexToR(h) {
    return parseInt((cutHex(h)).substring(0, 2), 16)
}

function hexToG(h) {
    return parseInt((cutHex(h)).substring(2, 4), 16)
}

function hexToB(h) {
    return parseInt((cutHex(h)).substring(4, 6), 16)
}

function cutHex(h) {
    return (h.charAt(0) == "#") ? h.substring(1, 7) : h
}

function hexToRgb(_hex) {
    return [hexToR(_hex), hexToG(_hex), hexToB(_hex)];
}

// get random chromaticity value
function getRandomChro(_a, _b) {
    const _min = _a < _b ? _a : _b;
    const _max = _a < _b ? _b : _a;
    return f(r() * (_max - _min)) + _min;
}

// get rgba value
function random_rgba(theme = 'grey') {

    if (!theme || theme == 'grey') {
        const idx = Math.floor(Math.random() * 100000) % 8;
        theme = eyeEcho_theme_color_list[idx];
    }

    _range = [];
    _range.push(hexToRgb(eyeEcho_game_config.text.theme[theme].value1));
    _range.push(hexToRgb(eyeEcho_game_config.text.theme[theme].value2));

    return [getRandomChro(_range[0][0], _range[1][0]), getRandomChro(_range[0][1], _range[1][1]), getRandomChro(_range[0][2], _range[1][2]), r()];
}

// get rgba style
function getRgbaColor(rgba) {
    return `rgba(${o(rgba[0]) % 256}, ${o(rgba[1]) % 256}, ${o(rgba[2]) % 256}, ${rgba[3] < 1 ? rgba[3] < ALPHA_MIN ? 1 : rgba[3] : 1})`;
}

// convert degree to radians
function toRadians(angle) {
    return angle * (Math.PI / 180);
}

// unify vector
function unifyVector(_vec) {
    const _l = Math.sqrt(_vec.x * _vec.x + _vec.y * _vec.y);
    return {
        x: _vec.x / _l,
        y: _vec.y / _l
    };
}

animate = ({
    duration,
    draw,
    timing
}) => {
    let start = performance.now();
    requestAnimationFrame(animateFrame = (time) => {
        let timeFraction = (time - start) / duration;
        dropingProgress = timeFraction;
        if (timeFraction > 1) {
            timeFraction = 1;
        }
        let progress = timing(timeFraction)
        draw(progress);
        if (timeFraction && timeFraction < 1) {
            window.requestAnimationFrame(animateFrame);
        }
    });
}

// defind Shape class
class Shape {
    constructor(ctx, width, height) {
        this.box = {
            width: width,
            height: height
        };
        this.ctx = ctx;
        this.setType();
        if (this.type == SHAPE_TYPE.CIRCLE) {
            this.r = getRandomInt(width / 3 - SHAPE_SIZE_MIN) + SHAPE_SIZE_MIN;
            this.width = this.r * 2;
            this.height = this.r * 2;
        } else if (this.type == SHAPE_TYPE.RECTANGLE) {
            this.width = getRandomInt((width - SHAPE_SIZE_MIN)) + SHAPE_SIZE_MIN;
            this.height = getRandomInt((height / 2 - SHAPE_SIZE_MIN)) + SHAPE_SIZE_MIN;
        } else {
            this.r = getRandomInt(width / 2 - SHAPE_SIZE_MIN) + SHAPE_SIZE_MIN;
            this.width = this.r * 2;
            this.height = this.r * 2;
            this.start_angle = r();
        }

        this.setDirection();

        this.color = random_rgba();
        this.speed = width / 200;
    }

    setType() {
        switch (getRandomInt() % 3) {
            case 0:
                this.type = SHAPE_TYPE.RECTANGLE;
                break;
            case 1:
                this.type = SHAPE_TYPE.CIRCLE;
                break;
            case 2:
                this.type = SHAPE_TYPE.TRIANGLE;
                break;
        }
    }

    setDirection() {
        let _start_p = {
                x: 0,
                y: 0
            },
            _end_p = {
                x: 0,
                y: 0
            };
        const _o = [this.width / 2, this.height / 2];
        const box = {
            width: this.box.width,
            height: this.box.height,
        };

        let direction = getRandomInt() % 4;

        switch (direction) {
            case 0: // right
                _start_p.x = -_o[0] / 2;
                _start_p.y = r() * box.height;
                _end_p.x = box.width + _o[0] / 2;
                _end_p.y = r() * box.height;
                break;
            case 1: // down
                _start_p.x = r() * box.width;
                _start_p.y = -_o[1] / 2;
                _end_p.x = r() * box.width;
                _end_p.y = box.height + _o[1];
                break;
            case 2: // left
                _start_p.x = box.width + _o[0] / 2;
                _start_p.y = r() * box.height;
                _end_p.x = -_o[0];
                _end_p.y = r() * box.height;
                break;
            case 3: // up
                _start_p.x = r() * box.width;
                _start_p.y = box.height + _o[1] / 2;
                _end_p.x = r() * box.width;
                _end_p.y = -_o[1];
                break;
            default:
                _end_p.x = -_o[0];
                _end_p.y = r() * box.height;
                _start_p.x = box.width + _o[0] / 2;
                _start_p.y = r() * box.height;
                break;
        }


        this.start_p = _start_p;
        this.end_p = _end_p;

        this.x = this.start_p.x;
        this.y = this.start_p.y;

        const _a = {
            x: _end_p.x - _start_p.x,
            y: _end_p.y - _start_p.y
        };

        this.direction = _a;
    }

    move = () => {
        if (this.direction.x == 0) {
            this.y += this.direction.y > 0 ? this.speed : -this.speed;
        } else if (this.direction.y == 0) {
            this.x += this.direction.x > 0 ? this.speed : -this.speed;
        } else {
            const direction = unifyVector(this.direction);
            this.x += this.speed * direction.x;
            this.y += this.speed * direction.y;
        }
    }

    // define draw functions
    drawRect = (x, y, width, height, color) => {
        this.ctx.beginPath();
        this.ctx.rect(x - width / 2, y - height / 2, width, height);
        this.ctx.fillStyle = getRgbaColor(color);
        this.ctx.fill();
        this.ctx.closePath();
    }

    drawCircle = (x, y, r, color) => {
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI * 2);
        this.ctx.fillStyle = getRgbaColor(color);
        this.ctx.fill();
        this.ctx.closePath();
    }

    drawTriangle = (x, y, r, st_a, color) => {
        const ang_step = 120 / 180 * Math.PI;
        this.ctx.beginPath();
        this.ctx.moveTo(x + r * Math.cos(st_a), y + r * Math.sin(st_a));
        this.ctx.lineTo(x + r * Math.cos(st_a + ang_step), y + r * Math.sin(st_a + ang_step));
        this.ctx.lineTo(x + r * Math.cos(st_a + 2 * ang_step), y + r * Math.sin(st_a + 2 * ang_step));
        this.ctx.fillStyle = getRgbaColor(color);
        this.ctx.fill();
        this.ctx.closePath();
    }

    draw = () => {
        switch (this.type) {
            case SHAPE_TYPE.RECTANGLE:
                this.drawRect(this.x, this.y, this.width, this.height, this.color);
                break;
            case SHAPE_TYPE.CIRCLE:
                this.drawCircle(this.x, this.y, this.r, this.color);
                break;
            case SHAPE_TYPE.TRIANGLE:
                this.drawTriangle(this.x, this.y, this.r, this.start_angle, this.color);
                break;
        }
    }
};


class GameBoard {
    constructor(canvas) {
        this.setCanvas(canvas);
    }

    setCanvas = (canvas) => {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.theme = eyeEcho_game_config.theme;
        this.bg_color = [random_rgba(this.theme), random_rgba(this.theme)];
        this.init();
    }

    init = (countdown = eyeEcho_game_config.countdown) => {
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.lr_p = 0;
        this.t_p = this.height / 5;
        this.countdown = countdown;
        this.activeShape = null;
        this.staticShapes = [];
        this.touchedHeight = this.height;
        this.isStarted = false;
        this.isUploading = false;
        this.isReady = 4;
        this.countdownTimer = null;
        this.backgroundTimer = null;
        this.moveTimer = null;
        this.setActiveShape();
        this.isEnableEye = false;
        this.blinkIcon = new Image();
        this.blinkIcon.setAttribute("crossOrigin", "Anonymous");
        this.blinkIcon.src = 'http://cdn.onlinewebfonts.com/svg/img_457301.png';
        this.drawMenu();

        //init global info values
        eyeEcho_result_info.count = 0;
        eyeEcho_result_info.period = 0;
    }

    setActiveShape = () => {
        this.activeShape = new Shape(this.ctx, this.width, this.height);
    }

    readyToStart = () => {
        this.drawReadyToStart();
        setIntervalX(() => {
            this.isReady--;
            this.drawReadyToStart();
        }, 1000, 4);
    }

    startGame = () => {
        if (this.isStarted || this.isUploading)
            return;

        this.init();

        this.isStarted = true;

        this.countdownTimer = setInterval(() => {
            this.countdown--;
            eyeEcho_result_info.period++;
        }, 1000);

        this.moveTimer = setInterval(() => {
            this.moveShape();
        }, 1);

        this.draw();
    }

    uploadImage = () => {
        try {
            this.isUploading = true;
            this.isEnableEye = false;
            const pngUrl = this.canvas.toDataURL("image/png", 1);
            setResultImageSrc(pngUrl);
            setResultBlinkCount();
            this.drawMenu();

            const url = 'https://imb-staging.herokuapp.com/eye-echo/upload';
            fetch(url, {
                    method: 'POST',
                    headers: {
                        Accept: 'application/json',
                        'Content-Type': 'application/json;charset=UTF-8'
                    },
                    body: JSON.stringify({
                        "image": pngUrl
                    })
                })
                .then(resp => resp.json())
                .then(data => {
                    this.isUploading = false;
                    if (data.status === 'error') {
                        alert('error: ', data.message);
                    } else {
                        //alert(data.message + '\n' + eyeEcho_menu[eyeEcho_game_config.lang].uploading.success + '\n' + data.image_url);
                        eyeEchoPage('eyeEcho_results_page', 'eyeEcho_result_created_image');
                    }
                    this.drawMenu();
                });
        } catch (err) {
            console.log(err);
            this.isUploading = false;
            this.drawMenu();
        }
    }

    endGame = () => {
        if (!this.isStarted) return;
        clearInterval(this.countdownTimer);
        clearInterval(this.moveTimer);
        this.isStarted = false;
        this.uploadImage();
    }

    addStaticShape = () => {
        this.staticShapes.push(this.activeShape);
    }

    // check the active shape is out of board and set top height
    checkShape = () => {
        const x = this.activeShape.x;
        const y = this.activeShape.y;
        const width = this.activeShape.width;
        const height = this.activeShape.height;


        if (x + width < 0 ||
            x - width > this.width || y + height < 0 || y - height > this.height) {
            this.setActiveShape();
            return;
        }
    }

    // check if end condition
    checkEndCondition = () => {
        return this.countdown < 1;
    }

    // drop shape
    dropShape = () => {
        if (this.isUploading) return;
        eyeEcho_result_info.count++;
        if (!this.isStarted) return;
        this.isEnableEye = true;

        setTimeout(() => {
            this.isEnableEye = false;
        }, 300);

        this.addStaticShape();
        this.setActiveShape();
    }

    // move shape left or right
    moveShape = () => {
        this.activeShape.move();
        this.checkShape();
    }

    // define draw functions
    erase = () => {
        this.ctx.restore();
        this.ctx.save();
        this.ctx.clearRect(0, 0, this.width, this.height);
    }

    // draw ready to start
    drawReadyToStart = () => {
        if (this.isReady < 1) {
            animate({
                duration: 1000,
                draw: (progress) => {
                    if (progress >= 1) {
                        this.startGame();
                        return;
                    }
                    if (progress < 0) return;
                    const _r = 1000 * progress + this.width / 5;
                    this.erase();
                    this.ctx.beginPath();
                    this.ctx.arc(this.width / 2, this.height / 2, Math.abs(_r), 0, Math.PI * 2);
                    this.ctx.clip();
                    this.drawBackground();
                    this.ctx.fillStyle = "rgba(255, 255, 255, " + (0.6 - progress > 0 ? 0.6 - progress : 0.0) + ")";
                    this.ctx.font = 'bold ' + (20 + 20 * progress) + 'vw Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(1, this.width / 2, this.height / 2);
                },
                timing: (timeFraction) => {
                    return timeFraction;
                }
            });
        } else if (this.isReady > 3) {
            animate({
                duration: 1000,
                draw: (progress) => {
                    if (progress < 0) return;
                    this.erase();
                    this.ctx.beginPath();
                    this.ctx.arc(this.width / 2, this.height / 2, this.width / 5, 0, Math.PI * 2);
                    this.ctx.clip();
                    this.ctx.globalAlpha = progress;
                    this.drawBackground();
                    this.ctx.fillStyle = "rgba(255, 255, 255, " + progress + ")";
                    this.ctx.font = 'bold 20vw Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(3, this.width / 2, this.height / 2);
                },
                timing: (timeFraction) => {
                    return timeFraction;
                }
            });
        } else {
            this.erase();
            const txtHeight = this.ctx.measureText('M').width;
            const txtWidth = this.ctx.measureText(this.countdown);
            this.ctx.beginPath();
            this.ctx.arc(this.width / 2, this.height / 2, this.width / 5, 0, Math.PI * 2);
            this.ctx.clip();
            this.drawBackground();
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.font = 'bold 20vw Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(this.isReady, this.width / 2, this.height / 2);
        }
    }

    // draw menu to show how to play game
    drawMenu = () => {
        if (this.isUploading) {
            this.ctx.fillStyle = '#000000';
            this.ctx.font = '6vw Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(eyeEcho_game_config.text.game.uploading.title, this.width / 2, this.height / 2);
            this.ctx.font = '4vw Arial'
            this.ctx.fillText(eyeEcho_game_config.text.game.uploading.description, this.width / 2, (this.height / 4) * 3);
            return;
        }
    }

    // draw time remaining
    drawCountdown = () => {
        if (this.countdown < 1) return;

        this.ctx.fillStyle = '#FFF';
        this.ctx.textAlign = 'left';
        this.ctx.textBaseline = 'middle';
        this.ctx.font = '8vw Arial Black';

        const txtHeight = this.ctx.measureText('M').width;
        const countdownTextWidth = this.ctx.measureText(this.countdown);

        this.ctx.fillText(this.countdown, txtHeight / 2, txtHeight);
        this.ctx.font = '4vw Arial';
        this.ctx.fillText(' sec', txtHeight / 2 + countdownTextWidth.width, txtHeight);

        this.ctx.textAlign = 'right';
        this.ctx.font = '4vw Arial';
        const blinksTextWidth = this.ctx.measureText(' blinks');
        this.ctx.fillText(' blinks', this.width - txtHeight / 2, txtHeight);
        this.ctx.font = '8vw Arial Black';
        this.ctx.fillText(eyeEcho_result_info.count, this.width - txtHeight / 2 - blinksTextWidth.width, txtHeight);

    }

    // draw shapes
    drawShapes = () => {
        this.staticShapes.forEach(function (shape) {
            shape.draw();
        })
    }

    // draw blink icon when the shape start to drop
    drawBlinkIcon = () => {
        if (this.isEnableEye && !this.isUploading) {
            this.ctx.drawImage(this.blinkIcon, this.width / 2 - this.width / 10, this.height / 2 - this.width / 10, this.width / 5, this.width / 5);
        }
    }

    // draw gradient background.
    drawBackground = () => {
        let grd = this.ctx.createLinearGradient(90, 0, 0, this.width);
        grd.addColorStop(0, getRgbaColor(this.bg_color[0]));
        grd.addColorStop(1, getRgbaColor(this.bg_color[1]));
        this.ctx.fillStyle = grd;
        this.ctx.fillRect(0, 0, this.width, this.height);
    }

    // draw by time
    draw = (time) => {
        this.erase();
        this.drawBackground();
        this.drawShapes();
        if (this.checkEndCondition()) {
            this.endGame();
        } else {
             this.activeShape.draw();
            this.drawCountdown();
            this.drawBlinkIcon();
            window.requestAnimationFrame(this.draw);
        }
    }
};

/**
 *  get elements
 */

const eyeEcho_blink_game_container = document.getElementById('eyeEcho_blink_game_container');
const eyeEcho_blink_game_canvas = document.getElementById("eyeEcho_blink_game_board");
const eyeEcho_blink_game_ctx = eyeEcho_blink_game_canvas.getContext("2d");

/**
 * set class name to change eyeEcho_blink_game_canvas game board width dynamically by eyeEcho_blink_game_container's boundbox size
 */

chageWidthClass = () => {
    if (!gameboard) return;
    eyeEcho_blink_game_canvas.width = eyeEcho_blink_game_container.offsetWidth;
    eyeEcho_blink_game_canvas.height = eyeEcho_blink_game_container.offsetHeight;

    gameboard.setCanvas(eyeEcho_blink_game_canvas);
}

function eyeEcho_translate() {
    const allDom = document.getElementsByTagName("*");
    for (let i = 0; i < allDom.length; i++) {
        const elem = allDom[i];
        const key = elem.getAttribute("eyeEcho-data-tag");
        if (key != null) {
            elem.innerHTML = eyeEcho_game_config.text.page[key];
        }
    }
}

createGameBoard = () => {

    eyeEcho_translate();

    gameboard = new GameBoard(eyeEcho_blink_game_canvas);

    chageWidthClass();

    //window.addEventListener('resize', chageWidthClass);

    //eyeEcho_blink_game_canvas.addEventListener('click', gameboard.startGame);

    document.addEventListener('mousedown', function (event) {
        lastDownTarget = event.target;
    }, false);

    document.addEventListener('keydown', function (e) {
        if (lastDownTarget == eyeEcho_blink_game_canvas) {
            e.preventDefault();
            if (e.keyCode === 40) {
                gameboard.dropShape();
            }
        }
    }, false);
}

eyeEcho_load_menu_data(createGameBoard);